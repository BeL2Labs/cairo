//! > Unused coupon

//! > test_runner_name
test_program_generator

//! > cairo
extern fn coupon_buy<T>() -> T nopanic;
extern fn coupon_refund<T>(c: T) nopanic;
extern fn drop<T>(c: T) nopanic;

struct MyStruct {
    c: bar::<u8>::Coupon,
    box: Box::<bar::<u8>::Coupon>,
}

fn foo(my_struct: MyStruct, coupon: bar::<u8>::Coupon) -> MyStruct {
    coupon_refund(my_struct.c);
    coupon_refund(my_struct.box.unbox());
    drop(coupon);
    MyStruct{ c: coupon_buy(), box: BoxTrait::new(coupon_buy()) }
}

fn return_coupon() -> bar::<u8>::Coupon {
    coupon_buy()
}

fn bar<T>() -> felt252 {
    10
}

//! > sierra_code
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type Box<Unit> = Box<Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type test::MyStruct = Struct<ut@test::MyStruct, Unit, Box<Unit>> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc struct_deconstruct<test::MyStruct> = struct_deconstruct<test::MyStruct>;
libfunc drop<Unit> = drop<Unit>;
libfunc unbox<Unit> = unbox<Unit>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc into_box<Unit> = into_box<Unit>;
libfunc struct_construct<test::MyStruct> = struct_construct<test::MyStruct>;

struct_deconstruct<test::MyStruct>([0]) -> ([2], [3]); // 0
drop<Unit>([2]) -> (); // 1
unbox<Unit>([3]) -> ([4]); // 2
drop<Unit>([4]) -> (); // 3
drop<Unit>([1]) -> (); // 4
struct_construct<Unit>() -> ([5]); // 5
struct_construct<Unit>() -> ([6]); // 6
into_box<Unit>([6]) -> ([7]); // 7
struct_construct<test::MyStruct>([5], [7]) -> ([8]); // 8
return([8]); // 9
struct_construct<Unit>() -> ([0]); // 10
return([0]); // 11

test::foo@0([0]: test::MyStruct, [1]: Unit) -> (test::MyStruct);
test::return_coupon@10() -> (Unit);

//! > ==========================================================================

//! > Unused coupons with recursive types

//! > test_runner_name
test_program_generator

//! > cairo
use nullable::null;
extern fn coupon_buy<T>() -> T nopanic;

impl DropCoupon of Drop<bar::Coupon>;

#[derive(Drop)]
struct MyStruct {
    c: bar::Coupon,
    my_struct: Nullable::<MyStruct>,
}

fn foo(my_struct: MyStruct, coupon: bar::Coupon) -> MyStruct {
    MyStruct{
        c: coupon_buy(),
        my_struct: null(),
    }
}

fn bar() -> felt252 {
    10
}

//! > sierra_code
type Coupon<user@test::bar> = Coupon<user@test::bar> [storable: true, drop: true, dup: false, zero_sized: true];
type Nullable<test::MyStruct> = Nullable<test::MyStruct> [storable: true, drop: true, dup: false, zero_sized: false];
type test::MyStruct = Struct<ut@test::MyStruct, Coupon<user@test::bar>, Nullable<test::MyStruct>> [storable: true, drop: true, dup: false, zero_sized: false];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];

libfunc drop<test::MyStruct> = drop<test::MyStruct>;
libfunc drop<Unit> = drop<Unit>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc null<test::MyStruct> = null<test::MyStruct>;
libfunc struct_construct<test::MyStruct> = struct_construct<test::MyStruct>;
libfunc store_temp<test::MyStruct> = store_temp<test::MyStruct>;
libfunc felt252_const<10> = felt252_const<10>;
libfunc store_temp<felt252> = store_temp<felt252>;

drop<test::MyStruct>([0]) -> (); // 0
drop<Unit>([1]) -> (); // 1
struct_construct<Unit>() -> ([2]); // 2
null<test::MyStruct>() -> ([3]); // 3
struct_construct<test::MyStruct>([2], [3]) -> ([4]); // 4
store_temp<test::MyStruct>([4]) -> ([4]); // 5
return([4]); // 6
felt252_const<10>() -> ([0]); // 7
store_temp<felt252>([0]) -> ([0]); // 8
return([0]); // 9

test::foo@0([0]: test::MyStruct, [1]: Unit) -> (test::MyStruct);
test::bar@7() -> (felt252);
