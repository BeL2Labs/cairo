//! > Unused coupon

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
extern fn coupon_buy<T>() -> T nopanic;
extern fn coupon_refund<T>(c: T) nopanic;

struct MyStruct {
    c: bar::<u8>::Coupon,
}

fn foo(my_struct: MyStruct) -> MyStruct {
    coupon_refund(my_struct.c);
    // coupon_refund(coupon_buy::<bar::<u8>::Coupon>());
    // bar::<u8>();
    MyStruct{ c: coupon_buy() }
}

#[inline(never)]
fn bar<T>() -> felt252 {
    10
}

//! > casm
ret;

//! > function_costs
test::foo: OrderedHashMap({})

//! > sierra_code
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type test::MyStruct = Struct<ut@test::MyStruct, Unit> [storable: true, drop: true, dup: true, zero_sized: true];

libfunc struct_deconstruct<test::MyStruct> = struct_deconstruct<test::MyStruct>;
libfunc drop<Unit> = drop<Unit>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc struct_construct<test::MyStruct> = struct_construct<test::MyStruct>;

struct_deconstruct<test::MyStruct>([0]) -> ([1]); // 0
drop<Unit>([1]) -> (); // 1
struct_construct<Unit>() -> ([2]); // 2
struct_construct<test::MyStruct>([2]) -> ([3]); // 3
return([3]); // 4

test::foo@0([0]: test::MyStruct) -> (test::MyStruct);
